{
  "version": "2.0.0",
  "project": {
    "name": "MindStrike",
    "vision": "Empower knowledge workers with an AI-powered assistant platform that seamlessly integrates conversational AI, visual knowledge mapping, and autonomous agent workflows to enhance productivity, creativity, and decision-making.",
    "projectType": "desktop-app"
  },
  "problemSpace": {
    "primaryProblem": {
      "title": "Information Overload and Cognitive Complexity in AI-Assisted Knowledge Work",
      "description": "Knowledge workers struggle to manage information overload and cognitive complexity when working with multiple AI conversations, research threads, and interconnected ideas simultaneously. Traditional AI chat interfaces are linear and isolated, making it difficult to track multiple conversation threads, visualize relationships between concepts, organize knowledge, and leverage AI agents for complex workflows.",
      "impact": "high"
    }
  },
  "solutionSpace": {
    "overview": "MindStrike provides a unified workspace that combines multi-threaded conversational AI, interactive mind mapping for visual knowledge organization, and autonomous agent workflows. Users can manage multiple AI conversation threads simultaneously, visualize connections between ideas using mind maps, and leverage specialized AI agents for complex tasks, all within a single integrated desktop application.",
    "capabilities": [
      {
        "name": "Multi-threaded Conversational AI",
        "description": "Manage multiple independent AI conversation threads simultaneously, allowing users to explore different aspects of a problem or maintain separate context-specific discussions"
      },
      {
        "name": "Interactive Mind Mapping",
        "description": "Create, edit, and visualize knowledge graphs using interactive mind maps with node-based interfaces, enabling users to organize concepts, relationships, and insights visually"
      },
      {
        "name": "Autonomous Agent Workflows",
        "description": "Define and execute complex AI agent workflows that can perform multi-step tasks autonomously, leveraging specialized agents for different capabilities"
      },
      {
        "name": "Multi-Model AI Support",
        "description": "Configure and switch between multiple LLM providers (local and cloud-based) including Anthropic, OpenAI, Google, Ollama, and custom models with flexible model management"
      },
      {
        "name": "Workspace Management",
        "description": "Organize work into customizable workspaces with persistent state, allowing users to maintain different contexts for various projects or research areas"
      },
      {
        "name": "Code Editing and Integration",
        "description": "Built-in Monaco code editor for working with code snippets, scripts, and technical content directly within the AI workflow"
      }
    ]
  },
  "personas": [
    {
      "name": "Knowledge Worker",
      "description": "Professionals who work with complex information, research, and analysis - including researchers, analysts, consultants, writers, and developers",
      "goals": [
        "Manage multiple AI conversations to explore different aspects of a problem",
        "Organize and visualize connections between ideas and research findings",
        "Increase productivity by leveraging AI for knowledge synthesis"
      ]
    },
    {
      "name": "AI Power User",
      "description": "Technical users who want advanced control over AI models, parameters, and workflows - including ML engineers, prompt engineers, and AI researchers",
      "goals": [
        "Configure and fine-tune local and cloud-based LLM models",
        "Create and manage complex AI agent workflows",
        "Experiment with different AI models and compare results"
      ]
    }
  ],
  "architectureDiagrams": [
    {
      "title": "Overall Architecture",
      "mermaidCode": "graph TB\n    subgraph Electron[\"Electron Desktop App\"]\n        subgraph Renderer[\"Renderer Process\"]\n            React[\"React 18 + TypeScript\"]\n            Vite[\"Vite Dev Server\"]\n            Zustand[\"Zustand State Management\"]\n            SSEBus[\"SSE Event Bus\"]\n        end\n        \n        subgraph Main[\"Main Process\"]\n            ElectronMain[\"Electron Main\"]\n            NestServer[\"Embedded NestJS Server :3001\"]\n        end\n    end\n    \n    subgraph Backend[\"Backend Services\"]\n        NestJS[\"NestJS Framework\"]\n        LangChain[\"LangChain AI\"]\n        MCP[\"Model Context Protocol\"]\n    end\n    \n    subgraph Storage[\"Data Persistence\"]\n        FileSystem[\"File System\"]\n        LocalStorage[\"Browser LocalStorage\"]\n        Workspace[\"Workspace Root\"]\n    end\n    \n    React --> Zustand\n    React --> SSEBus\n    Zustand --> React\n    SSEBus --> React\n    \n    React -->|HTTP/REST| NestServer\n    NestServer -->|SSE Stream| SSEBus\n    \n    ElectronMain --> NestServer\n    ElectronMain --> Renderer\n    \n    NestServer --> NestJS\n    NestJS --> LangChain\n    NestJS --> MCP\n    NestJS --> FileSystem\n    \n    Zustand -.->|persist| LocalStorage\n    NestJS -.->|read/write| Workspace\n    \n    Workspace --> FileSystem\n    \n    style Electron fill:#e1f5ff\n    style Backend fill:#fff4e1\n    style Storage fill:#f0f0f0"
    },
    {
      "title": "Frontend State Management",
      "mermaidCode": "graph LR\n    subgraph UI[\"React Components\"]\n        ChatView[\"ChatView\"]\n        MindMapEditor[\"MindMapEditor\"]\n        ThreadList[\"ThreadList\"]\n        MessageList[\"MessageList\"]\n    end\n    \n    subgraph Stores[\"Zustand Stores\"]\n        AppStore[\"useAppStore<br/>• Font settings<br/>• Active view<br/>• Workspace roots<br/>• LocalStorage persist\"]\n        ThreadsStore[\"useThreadsStore<br/>• Thread list<br/>• Active thread<br/>• API-bound actions\"]\n        ChatStore[\"useChatThreadStore<br/>• Factory pattern<br/>• Per-thread messages<br/>• Message CRUD\"]\n        MindMapStore[\"useMindMapStore<br/>• nodes[], edges[]<br/>• Undo/redo (Immer)<br/>• Generation state\"]\n    end\n    \n    subgraph EventBus[\"Real-time Events\"]\n        SSE[\"SSE Event Bus<br/>• Single EventSource<br/>• Topic routing<br/>• Content decoding\"]\n    end\n    \n    ChatView --> ThreadsStore\n    ChatView --> ChatStore\n    ThreadList --> ThreadsStore\n    MessageList --> ChatStore\n    MindMapEditor --> MindMapStore\n    \n    ThreadsStore --> ChatView\n    ChatStore --> MessageList\n    MindMapStore --> MindMapEditor\n    \n    SSE --> MindMapStore\n    SSE --> ChatStore\n    SSE --> ThreadsStore\n    \n    AppStore -.->|persist| LocalStorage[\"LocalStorage\"]\n    \n    style Stores fill:#e3f2fd\n    style UI fill:#fff3e0\n    style EventBus fill:#f3e5f5"
    },
    {
      "title": "Backend NestJS Modules",
      "mermaidCode": "graph TB\n    subgraph NestJS[\"NestJS Application\"]\n        AppModule[\"AppModule<br/>(Root Module)\"]\n        \n        subgraph Core[\"Core Modules\"]\n            ChatModule[\"ChatModule<br/>• ConversationService<br/>• MessageService<br/>• Thread persistence\"]\n            AgentsModule[\"AgentsModule<br/>• ThreadsController<br/>• Role management\"]\n            MindMapModule[\"MindMapModule<br/>• MindmapService<br/>• LangChain generation<br/>• SSE streaming\"]\n        end\n        \n        subgraph Communication[\"Communication\"]\n            EventsModule[\"EventsModule<br/>• SseService<br/>• Client management<br/>• Event broadcasting\"]\n        end\n        \n        subgraph AI[\"AI Integration\"]\n            LLMModule[\"LLMModule<br/>• Model scanning<br/>• LangChain integration<br/>• Model routing\"]\n            MCPModule[\"MCPModule<br/>• Tool registration<br/>• Server lifecycle<br/>• Multi-platform\"]\n        end\n        \n        subgraph Data[\"Data & Storage\"]\n            WorkspaceModule[\"WorkspaceModule<br/>• File operations<br/>• Directory scanning\"]\n            ContentModule[\"ContentModule<br/>• Large content storage<br/>• 5-min TTL cleanup\"]\n            SharedModule[\"SharedModule<br/>• GlobalConfigService<br/>• Shared utilities\"]\n        end\n    end\n    \n    subgraph External[\"External Services\"]\n        LangChain[\"LangChain<br/>• Anthropic<br/>• OpenAI<br/>• Ollama<br/>• Google GenAI\"]\n        FileSystem[\"File System<br/>• mindstrike-chats.json<br/>• mindmaps/\"]\n    end\n    \n    AppModule --> ChatModule\n    AppModule --> AgentsModule\n    AppModule --> MindMapModule\n    AppModule --> EventsModule\n    AppModule --> LLMModule\n    AppModule --> MCPModule\n    AppModule --> WorkspaceModule\n    AppModule --> ContentModule\n    AppModule --> SharedModule\n    \n    ChatModule --> EventsModule\n    MindMapModule --> EventsModule\n    MindMapModule --> LLMModule\n    LLMModule --> LangChain\n    \n    ChatModule -.->|read/write| FileSystem\n    MindMapModule -.->|read/write| FileSystem\n    WorkspaceModule -.->|scan| FileSystem\n    \n    style Core fill:#e8f5e9\n    style Communication fill:#fff3e0\n    style AI fill:#e1f5fe\n    style Data fill:#f3e5f5"
    },
    {
      "title": "Real-time Communication Flow (SSE)",
      "mermaidCode": "sequenceDiagram\n    participant UI as React UI\n    participant SSEBus as SSE Event Bus\n    participant EventSource as EventSource<br/>/api/events/stream\n    participant NestJS as NestJS Server\n    participant SseService as SseService\n    participant Module as Module<br/>(Chat/MindMap/etc)\n    \n    Note over UI,EventSource: Initial Connection\n    UI->>SSEBus: initialize()\n    SSEBus->>EventSource: new EventSource('/api/events/stream')\n    EventSource->>NestJS: GET /api/events/stream\n    NestJS->>SseService: addClient(response)\n    SseService-->>EventSource: Connected (200 OK)\n    \n    Note over EventSource,SseService: Keepalive Loop (30s)\n    loop Every 30 seconds\n        SseService->>EventSource: event: keepalive\n    end\n    \n    Note over UI,Module: User Action → Event Stream\n    UI->>NestJS: POST /api/threads/{id}/messages\n    NestJS->>Module: handleMessage()\n    \n    loop Streaming Response\n        Module->>SseService: broadcast('unified-events', CONTENT_CHUNK)\n        SseService->>EventSource: event: unified-events<br/>data: {type: 'content_chunk', ...}\n        EventSource->>SSEBus: onMessage(event)\n        SSEBus->>UI: emit('content_chunk', data)\n        UI->>UI: Update UI incrementally\n    end\n    \n    Module->>SseService: broadcast('unified-events', COMPLETED)\n    SseService->>EventSource: event: unified-events<br/>data: {type: 'completed', ...}\n    EventSource->>SSEBus: onMessage(event)\n    SSEBus->>UI: emit('completed', data)\n    UI->>UI: Finalize UI update\n    \n    Note over UI,SseService: Large Content Handling\n    Module->>SseService: broadcast with large content (>100MB)\n    SseService->>SseService: Store in contentStore with TTL\n    SseService->>EventSource: event with _large_content ref\n    EventSource->>SSEBus: onMessage(event)\n    SSEBus->>NestJS: GET /api/content/{contentId}\n    NestJS->>SSEBus: Return large content\n    SSEBus->>UI: emit with resolved content"
    },
    {
      "title": "Data Persistence Flow",
      "mermaidCode": "sequenceDiagram\n    participant User as User\n    participant UI as React Component\n    participant Store as Zustand Store\n    participant API as REST API\n    participant Service as NestJS Service\n    participant FS as File System\n    \n    Note over User,FS: Create New Thread\n    User->>UI: Click 'New Thread'\n    UI->>Store: useThreadsStore.createThread()\n    Store->>API: POST /api/threads\n    API->>Service: ConversationService.createThread()\n    Service->>Service: Add to in-memory Map\n    Service->>FS: Write mindstrike-chats.json\n    FS-->>Service: Success\n    Service-->>API: Return thread data\n    API-->>Store: { id, name, createdAt, ... }\n    Store->>Store: Update threads array\n    Store-->>UI: Trigger re-render\n    UI-->>User: Show new thread in list\n    \n    Note over User,FS: Send Message\n    User->>UI: Type message, click send\n    UI->>Store: useChatThreadStore.addMessage()\n    Store->>API: POST /api/threads/{id}/messages\n    API->>Service: ConversationService.addMessage()\n    Service->>Service: Update thread in Map\n    Service->>FS: Write mindstrike-chats.json\n    FS-->>Service: Success\n    Service-->>API: SSE stream (CONTENT_CHUNK)\n    API-->>Store: Via SSE Event Bus\n    Store->>Store: Append content to message\n    Store-->>UI: Trigger re-render\n    UI-->>User: Show streaming response\n    \n    Note over User,FS: Load on Startup\n    User->>UI: Open app\n    UI->>Store: useThreadsStore (auto-init)\n    Store->>API: GET /api/threads\n    API->>Service: ConversationService.getThreadList()\n    Service->>FS: Read mindstrike-chats.json\n    FS-->>Service: Return JSON data\n    Service->>Service: Load into in-memory Map\n    Service-->>API: Return threads array\n    API-->>Store: Thread list\n    Store-->>UI: Trigger re-render\n    UI-->>User: Display threads"
    },
    {
      "title": "Mind Map Generation Flow",
      "mermaidCode": "sequenceDiagram\n    participant User as User\n    participant UI as MindMapEditor\n    participant Store as useMindMapStore\n    participant API as REST API\n    participant Service as MindmapService\n    participant LangChain as LangChain Agent\n    participant SSE as SseService\n    \n    Note over User,SSE: Initiate Generation\n    User->>UI: Click 'Generate'\n    UI->>Store: startIterativeGeneration(prompt)\n    Store->>Store: Set isGenerating = true\n    Store->>API: POST /api/mindmaps/{id}/generate?stream=true\n    API->>Service: generateMindmap(prompt)\n    Service->>LangChain: Create agent with tools\n    \n    Note over LangChain,SSE: Streaming Generation Loop\n    loop For each AI decision\n        LangChain->>LangChain: Reason about next node\n        LangChain->>Service: Return tool call (create_node)\n        Service->>SSE: broadcast('unified-events', MINDMAP_CHANGE)\n        SSE->>Store: SSE event { action: 'create', text, parentId }\n        Store->>Store: applyMindmapChanges()\n        Store->>Store: Add node to nodes[]\n        Store->>Store: Add edge to edges[]\n        Store->>Store: Recalculate layout\n        Store-->>UI: Trigger re-render\n        UI-->>User: Show new node in real-time\n    end\n    \n    Note over Service,SSE: Generation Complete\n    Service->>SSE: broadcast('unified-events', TASK_COMPLETED)\n    SSE->>Store: SSE event { type: 'task_completed' }\n    Store->>Store: Set isGenerating = false\n    Store->>Store: Save mind map to file\n    Store-->>UI: Final re-render\n    UI-->>User: Generation complete\n    \n    Note over User,Store: User Edits\n    User->>UI: Drag node, edit text\n    UI->>Store: updateNode(id, changes)\n    Store->>Store: Update nodes[] (Immer draft)\n    Store->>Store: Push to history (undo/redo)\n    Store-->>UI: Re-render\n    \n    User->>UI: Ctrl+Z (Undo)\n    UI->>Store: undo()\n    Store->>Store: historyIndex -= 1\n    Store->>Store: Restore previous state\n    Store-->>UI: Re-render previous state"
    },
    {
      "title": "React Component Hierarchy",
      "mermaidCode": "graph TB\n    App[\"App.tsx<br/>Main Router\"]\n    \n    subgraph Layout[\"Layout Components\"]\n        Sidebar[\"Sidebar<br/>• Navigation<br/>• View selection\"]\n    end\n    \n    subgraph Views[\"Main Views\"]\n        ChatView[\"ChatView<br/>Multi-threaded chat\"]\n        MindMapsView[\"MindMapsView<br/>Mind map editor\"]\n        WorkspaceView[\"WorkspaceView<br/>File explorer\"]\n        AgentsView[\"AgentsView<br/>Agent management\"]\n        SettingsView[\"SettingsView<br/>Configuration\"]\n    end\n    \n    subgraph ChatComponents[\"Chat Components\"]\n        ThreadList[\"ThreadList<br/>• Thread items<br/>• New thread button\"]\n        ChatPanel[\"ChatPanel<br/>• MessageList<br/>• MessageInput\"]\n        MessageList[\"MessageList<br/>• Message components<br/>• Streaming updates\"]\n        NodePanel[\"NodePanel<br/>• Notes/citations\"]\n    end\n    \n    subgraph MindMapComponents[\"Mind Map Components\"]\n        MindMapList[\"MindMapList<br/>• Map items<br/>• New map button\"]\n        MindMapEditor[\"MindMapEditor<br/>ReactFlow canvas\"]\n        ReactFlow[\"ReactFlow<br/>• Custom nodes<br/>• Custom edges\"]\n        MindMapNodePanel[\"NodePanel<br/>• Properties<br/>• Edit controls\"]\n        GenerationPanel[\"GenerationPanel<br/>• Progress<br/>• Controls\"]\n    end\n    \n    subgraph Dialogs[\"Shared Dialogs\"]\n        ModelDialog[\"LocalModelLoadDialog\"]\n        ConnectionDialog[\"ConnectionMonitorDialog\"]\n        PromptsModal[\"PromptsModal\"]\n    end\n    \n    App --> Sidebar\n    App --> ChatView\n    App --> MindMapsView\n    App --> WorkspaceView\n    App --> AgentsView\n    App --> SettingsView\n    \n    ChatView --> ThreadList\n    ChatView --> ChatPanel\n    ChatView --> NodePanel\n    ChatPanel --> MessageList\n    \n    MindMapsView --> MindMapList\n    MindMapsView --> MindMapEditor\n    MindMapsView --> GenerationPanel\n    MindMapEditor --> ReactFlow\n    MindMapEditor --> MindMapNodePanel\n    \n    App --> Dialogs\n    \n    style App fill:#e3f2fd\n    style Layout fill:#fff3e0\n    style Views fill:#f3e5f5\n    style ChatComponents fill:#e8f5e9\n    style MindMapComponents fill:#fff9c4\n    style Dialogs fill:#fce4ec"
    }
  ]
}